# Rules Understanding

## Files Loaded

1. `/home/rubens/.claude/CLAUDE.md` - Global workflow rules
2. `/home/rubens/.claude/CLAUDE_PYTHON.md` - Python-specific guidelines
3. `/home/rubens/dev/personal/python/javamcp/README.md` - Project documentation

## Understanding Summary

### Global Workflow Rules (`CLAUDE.md`)

**Workflow Process:**
- Plan before implementation (mandatory)
- Get user approval on plans
- Store plans in `misc/tasks/` folder using checkbox format (`- [ ]`)
- Work incrementally, checking off tasks as completed
- Use high-level summaries for communication
- Add Review section when wrapping up
- Must check off checkboxes as tasks complete

**Coding Principles:**
- Clarity over cleverness
- SOLID & Clean Code principles
- Functions: <20 lines ideal, max 60 lines
- Descriptive names (no abbreviations)
- Document all public code
- No globals/static state
- Never swallow exceptions
- Avoid deep nesting (use early returns)
- No magic numbers (use named constants)
- Prefer immutability and pure functions
- Follow DRY principle
- Meaningful logging with context

**Critical Constraints:**
- NEVER create files unless absolutely necessary
- ALWAYS prefer editing existing files
- NEVER proactively create documentation files
- Do only what's asked, nothing more

### Python-Specific Guidelines (`CLAUDE_PYTHON.md`)

**Formatting & Style:**
- Use Black for auto-formatting
- Follow PEP8 standards

**Code Organization:**
- Follow Poetry standard layout (src/ and tests/)
- Feature-based organization
- Avoid large monolithic modules

**Language Best Practices:**
- Use Pydantic models for DTOs
- Use async/await for I/O operations
- Type hints everywhere
- Raise meaningful exceptions (not None)
- Use f-strings for formatting
- Use `is`/`is not` for None checks
- Use `with` for file operations
- Use `pathlib` instead of `os.path`
- Avoid wildcard imports
- Use `enumerate()` over `range(len())`
- Add `# Generated by Claude` to new files
- Add `# Modified by Claude` before modifications
- Run `pylint` to lint code

**Testing Requirements:**
- Use pytest framework
- Mirror src/ structure in tests/
- Use pytest fixtures for setup/teardown
- Use pytest-cov for coverage
- Mock only external dependencies (DB, APIs)
- Use pytest-mock for mocking
- Test behavior, not implementation
- Use @pytest.mark.parametrize for multiple inputs
- Keep tests small, focused, fast
- Test success and failure scenarios
- Aim for 80%+ coverage
- Clear test names
- Test edge cases and error handling

### Project Documentation (`README.md`)

**Project:** JavaMCP - Python-based MCP server for Java API exploration

**Key Features:**
- 4 MCP Tools: search_methods, analyze_class, extract_apis, generate_guide
- Rich context with Javadocs and API documentation
- Git repository integration
- ANTLR4-based parser for Java 21+ analysis
- Comprehensive indexing and query engine

**Architecture Modules:**
- models/ - Pydantic data models
- config/ - Configuration management
- repository/ - Git repository operations
- parser/ - ANTLR4 Java parser
- indexer/ - API indexing and query engine
- context/ - Context building and formatting
- tools/ - MCP tool implementations
- server/ - MCP server
- logging/ - Logging utilities
- utils/ - Helper utilities

**Current Status:**
- 247 tests across all modules
- 95%+ average coverage
- Python 3.13+, Poetry-based project

**Configuration:**
- Uses YAML/JSON config files
- Supports multiple Git repositories
- Configurable logging (INFO, console output)

## Application to Future Work

All future code changes, plans, and tasks will:
1. Follow the workflow process (plan → approval → implement with checkboxes)
2. Adhere to coding principles (clarity, SOLID, small functions, etc.)
3. Follow Python best practices (type hints, Pydantic, async/await, pathlib, etc.)
4. Maintain testing standards (pytest, 80%+ coverage, test behavior)
5. Respect critical constraints (edit over create, no unnecessary files)
6. Align with JavaMCP architecture and project structure

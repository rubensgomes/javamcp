# Generated by Claude
"""
ANTLR4 wrapper for parsing Java source files.
"""

from pathlib import Path

from antlr4 import CommonTokenStream, FileStream, InputStream
from antlr4.error.ErrorListener import ErrorListener

from javamcp.antlr4.JavaLexer import JavaLexer
from javamcp.antlr4.JavaParser import JavaParser
from javamcp.models.java_entities import JavaClass

from .ast_visitor import JavaASTVisitor
from .exceptions import InvalidJavaSourceError, ParseError


class JavaParseErrorListener(ErrorListener):
    """Custom error listener to capture parsing errors."""

    def __init__(self):
        super().__init__()
        self.errors: list[str] = []

    def syntaxError(
        self, recognizer, offendingSymbol, line, column, msg, e
    ):  # pylint: disable=unused-argument,too-many-arguments,too-many-positional-arguments
        """Capture syntax errors."""
        error_msg = f"Line {line}:{column} - {msg}"
        self.errors.append(error_msg)


class JavaSourceParser:
    """
    High-level wrapper around ANTLR4 Java parser.
    """

    def __init__(self):
        """Initialize the parser."""
        self.error_listener = JavaParseErrorListener()

    def parse_file(self, file_path: str) -> JavaClass:
        """
        Parse a Java source file and return JavaClass model.

        Args:
            file_path: Path to Java source file

        Returns:
            JavaClass model representing the parsed class

        Raises:
            InvalidJavaSourceError: If file cannot be parsed
            ParseError: If parsing fails
        """
        path = Path(file_path)
        if not path.exists():
            raise InvalidJavaSourceError(f"File not found: {file_path}")

        if not path.is_file():
            raise InvalidJavaSourceError(f"Not a file: {file_path}")

        try:
            input_stream = FileStream(str(path), encoding="utf-8")
            return self._parse_stream(input_stream, str(path))
        except Exception as e:
            raise ParseError(f"Failed to parse file {file_path}: {e}") from e

    def parse_string(
        self, source_code: str, source_name: str = "<string>"
    ) -> JavaClass:
        """
        Parse Java source code from string.

        Args:
            source_code: Java source code as string
            source_name: Optional name for source (for error messages)

        Returns:
            JavaClass model representing the parsed class

        Raises:
            InvalidJavaSourceError: If source cannot be parsed
            ParseError: If parsing fails
        """
        try:
            input_stream = InputStream(source_code)
            return self._parse_stream(input_stream, source_name)
        except Exception as e:
            raise ParseError(f"Failed to parse source {source_name}: {e}") from e

    def _parse_stream(self, input_stream, source_name: str) -> JavaClass:
        """
        Parse Java source from input stream.

        Args:
            input_stream: ANTLR4 input stream
            source_name: Source name for error messages

        Returns:
            JavaClass model

        Raises:
            InvalidJavaSourceError: If parsing fails
        """
        # Reset error listener
        self.error_listener.errors.clear()

        # Create lexer and parser
        lexer = JavaLexer(input_stream)
        lexer.removeErrorListeners()
        lexer.addErrorListener(self.error_listener)

        stream = CommonTokenStream(lexer)
        parser = JavaParser(stream)
        parser.removeErrorListeners()
        parser.addErrorListener(self.error_listener)

        # Parse compilation unit
        tree = parser.compilationUnit()

        # Check for errors
        if self.error_listener.errors:
            error_msg = "; ".join(self.error_listener.errors)
            raise InvalidJavaSourceError(f"Parse errors in {source_name}: {error_msg}")

        # Extract package and imports
        package_name = self._extract_package(tree)
        _ = self._extract_imports(tree)  # Not used yet, but may be needed in future

        # Visit AST to extract class information
        visitor = JavaASTVisitor(package_name, source_name)
        java_class = visitor.visit(tree)

        if java_class is None:
            raise InvalidJavaSourceError(f"No class definition found in {source_name}")

        return java_class

    def _extract_package(self, tree) -> str:
        """Extract package declaration from parse tree."""
        if tree.packageDeclaration():
            package_ctx = tree.packageDeclaration()
            if package_ctx.qualifiedName():
                return package_ctx.qualifiedName().getText()
        return ""

    def _extract_imports(self, tree) -> list[str]:
        """Extract import statements from parse tree."""
        imports = []
        for import_decl in tree.importDeclaration():
            if import_decl.qualifiedName():
                imports.append(import_decl.qualifiedName().getText())
        return imports

# Generated by Claude
"""
Custom ANTLR4 visitor for extracting Java API information.
"""

from typing import Optional

from antlr4 import ParserRuleContext

from javamcp.antlr4.JavaParserListener import JavaParserListener
from javamcp.models.java_entities import (JavaAnnotation, JavaClass, JavaField,
                                          JavaMethod, JavaParameter)


class JavaASTVisitor(JavaParserListener):
    """
    Custom visitor to extract Java class, method, and field information.
    """

    def __init__(self, package_name: str, source_name: str):
        """
        Initialize the visitor.

        Args:
            package_name: Package name from parse tree
            source_name: Source file name for reference
        """
        super().__init__()
        self.package_name = package_name
        self.source_name = source_name
        self.java_class: Optional[JavaClass] = None
        self.current_methods: list[JavaMethod] = []
        self.current_fields: list[JavaField] = []

    def visit(self, tree: ParserRuleContext) -> Optional[JavaClass]:
        """
        Visit the parse tree and extract Java class information.

        Args:
            tree: ANTLR4 parse tree

        Returns:
            JavaClass model or None
        """
        # Find the first type declaration (class, interface, enum)
        if hasattr(tree, "typeDeclaration") and tree.typeDeclaration():
            for type_decl in tree.typeDeclaration():
                if type_decl.classDeclaration():
                    self.java_class = self._extract_class(type_decl.classDeclaration())
                    return self.java_class
                if type_decl.interfaceDeclaration():
                    self.java_class = self._extract_interface(
                        type_decl.interfaceDeclaration()
                    )
                    return self.java_class
                if type_decl.enumDeclaration():
                    self.java_class = self._extract_enum(type_decl.enumDeclaration())
                    return self.java_class

        return None

    def _extract_class(self, class_ctx) -> JavaClass:
        """Extract JavaClass from class declaration context."""
        class_name = (
            class_ctx.identifier().getText() if class_ctx.identifier() else "Unknown"
        )
        fully_qualified_name = (
            f"{self.package_name}.{class_name}" if self.package_name else class_name
        )

        # Extract modifiers
        modifiers = self._extract_modifiers(class_ctx.parentCtx)

        # Check if abstract
        is_abstract = "abstract" in modifiers

        # Extract annotations
        annotations = self._extract_annotations(class_ctx.parentCtx)

        # Extract extends
        extends = None
        if class_ctx.EXTENDS():
            extends = class_ctx.typeType().getText() if class_ctx.typeType() else None

        # Extract implements
        implements = []
        if class_ctx.IMPLEMENTS():
            if class_ctx.typeList():
                implements = [t.getText() for t in class_ctx.typeList().typeType()]

        # Extract javadoc
        javadoc = self._extract_javadoc_for_context(
            class_ctx
        )  # pylint: disable=assignment-from-none

        # Extract members (methods and fields)
        if class_ctx.classBody():
            methods, fields = self._extract_class_body(class_ctx.classBody())
        else:
            methods, fields = [], []

        return JavaClass(
            name=class_name,
            fully_qualified_name=fully_qualified_name,
            package=self.package_name,
            modifiers=modifiers,
            annotations=annotations,
            extends=extends,
            implements=implements,
            methods=methods,
            fields=fields,
            javadoc=javadoc,
            is_interface=False,
            is_abstract=is_abstract,
            is_enum=False,
        )

    def _extract_interface(self, interface_ctx) -> JavaClass:
        """Extract JavaClass from interface declaration context."""
        interface_name = (
            interface_ctx.identifier().getText()
            if interface_ctx.identifier()
            else "Unknown"
        )
        fully_qualified_name = (
            f"{self.package_name}.{interface_name}"
            if self.package_name
            else interface_name
        )

        modifiers = self._extract_modifiers(interface_ctx.parentCtx)
        annotations = self._extract_annotations(interface_ctx.parentCtx)

        # Extract extends (interfaces can extend multiple interfaces)
        extends_list = []
        if interface_ctx.EXTENDS():
            if interface_ctx.typeList():
                extends_list = [
                    t.getText() for t in interface_ctx.typeList().typeType()
                ]

        javadoc = self._extract_javadoc_for_context(
            interface_ctx
        )  # pylint: disable=assignment-from-none

        # Extract methods from interface body
        if interface_ctx.interfaceBody():
            methods, fields = self._extract_interface_body(
                interface_ctx.interfaceBody()
            )
        else:
            methods, fields = [], []

        return JavaClass(
            name=interface_name,
            fully_qualified_name=fully_qualified_name,
            package=self.package_name,
            modifiers=modifiers,
            annotations=annotations,
            extends=extends_list[0] if extends_list else None,
            implements=extends_list[1:] if len(extends_list) > 1 else [],
            methods=methods,
            fields=fields,
            javadoc=javadoc,
            is_interface=True,
            is_abstract=False,
            is_enum=False,
        )

    def _extract_enum(self, enum_ctx) -> JavaClass:
        """Extract JavaClass from enum declaration context."""
        enum_name = (
            enum_ctx.identifier().getText() if enum_ctx.identifier() else "Unknown"
        )
        fully_qualified_name = (
            f"{self.package_name}.{enum_name}" if self.package_name else enum_name
        )

        modifiers = self._extract_modifiers(enum_ctx.parentCtx)
        annotations = self._extract_annotations(enum_ctx.parentCtx)

        javadoc = self._extract_javadoc_for_context(
            enum_ctx
        )  # pylint: disable=assignment-from-none

        methods: list[JavaMethod] = []
        fields: list[JavaField] = []

        return JavaClass(
            name=enum_name,
            fully_qualified_name=fully_qualified_name,
            package=self.package_name,
            modifiers=modifiers,
            annotations=annotations,
            methods=methods,
            fields=fields,
            javadoc=javadoc,
            is_interface=False,
            is_abstract=False,
            is_enum=True,
        )

    def _extract_class_body(self, body_ctx) -> tuple[list[JavaMethod], list[JavaField]]:
        """Extract methods and fields from class body."""
        methods = []
        fields = []

        if not body_ctx or not body_ctx.classBodyDeclaration():
            return methods, fields

        for decl in body_ctx.classBodyDeclaration():
            if decl.memberDeclaration():
                member = decl.memberDeclaration()

                # Check for method declaration
                if member.methodDeclaration():
                    method = self._extract_method(member.methodDeclaration(), decl)
                    if method:
                        methods.append(method)

                # Check for field declaration
                elif member.fieldDeclaration():
                    field_list = self._extract_fields(member.fieldDeclaration(), decl)
                    fields.extend(field_list)

                # Check for constructor
                elif member.constructorDeclaration():
                    constructor = self._extract_constructor(
                        member.constructorDeclaration(), decl
                    )
                    if constructor:
                        methods.append(constructor)

        return methods, fields

    def _extract_interface_body(
        self, body_ctx
    ) -> tuple[list[JavaMethod], list[JavaField]]:
        """Extract methods and fields from interface body."""
        methods = []
        fields = []

        if not body_ctx or not body_ctx.interfaceBodyDeclaration():
            return methods, fields

        for decl in body_ctx.interfaceBodyDeclaration():
            if decl.interfaceMemberDeclaration():
                member = decl.interfaceMemberDeclaration()

                # Check for method declaration
                if member.interfaceMethodDeclaration():
                    method = self._extract_interface_method(
                        member.interfaceMethodDeclaration(), decl
                    )
                    if method:
                        methods.append(method)

        return methods, fields

    def _extract_method(self, method_ctx, parent_ctx) -> Optional[JavaMethod]:
        """Extract JavaMethod from method declaration context."""
        method_name = (
            method_ctx.identifier().getText() if method_ctx.identifier() else "unknown"
        )

        # Extract return type
        return_type = (
            method_ctx.typeTypeOrVoid().getText()
            if method_ctx.typeTypeOrVoid()
            else "void"
        )

        # Extract parameters
        parameters = self._extract_parameters(method_ctx.formalParameters())

        # Extract modifiers
        modifiers = self._extract_modifiers(parent_ctx)

        # Extract annotations
        annotations = self._extract_annotations(parent_ctx)

        # Extract javadoc
        javadoc = self._extract_javadoc_for_context(
            parent_ctx
        )  # pylint: disable=assignment-from-none

        # Extract throws
        throws: list[str] = []
        if method_ctx.qualifiedNameList():
            throws = [
                qn.getText() for qn in method_ctx.qualifiedNameList().qualifiedName()
            ]

        return JavaMethod(
            name=method_name,
            return_type=return_type,
            parameters=parameters,
            modifiers=modifiers,
            annotations=annotations,
            javadoc=javadoc,
            throws=throws,
            is_constructor=False,
        )

    def _extract_interface_method(self, method_ctx, parent_ctx) -> Optional[JavaMethod]:
        """Extract JavaMethod from interface method declaration context."""
        method_name = (
            method_ctx.interfaceCommonBodyDeclaration().identifier().getText()
            if method_ctx.interfaceCommonBodyDeclaration().identifier()
            else "unknown"
        )

        # Extract return type
        return_type = (
            method_ctx.interfaceCommonBodyDeclaration().typeTypeOrVoid().getText()
            if method_ctx.interfaceCommonBodyDeclaration().typeTypeOrVoid()
            else "void"
        )

        # Extract parameters
        parameters = self._extract_parameters(
            method_ctx.interfaceCommonBodyDeclaration().formalParameters()
        )

        # Extract modifiers
        modifiers = self._extract_modifiers(parent_ctx)

        # Extract annotations
        annotations = self._extract_annotations(parent_ctx)

        # Extract javadoc
        javadoc = self._extract_javadoc_for_context(
            parent_ctx
        )  # pylint: disable=assignment-from-none

        throws: list[str] = []

        return JavaMethod(
            name=method_name,
            return_type=return_type,
            parameters=parameters,
            modifiers=modifiers,
            annotations=annotations,
            javadoc=javadoc,
            throws=throws,
            is_constructor=False,
        )

    def _extract_constructor(self, ctor_ctx, parent_ctx) -> Optional[JavaMethod]:
        """Extract constructor as JavaMethod."""
        ctor_name = (
            ctor_ctx.identifier().getText() if ctor_ctx.identifier() else "unknown"
        )

        # Extract parameters
        parameters = self._extract_parameters(ctor_ctx.formalParameters())

        # Extract modifiers
        modifiers = self._extract_modifiers(parent_ctx)

        # Extract annotations
        annotations = self._extract_annotations(parent_ctx)

        # Extract javadoc
        javadoc = self._extract_javadoc_for_context(
            parent_ctx
        )  # pylint: disable=assignment-from-none

        throws: list[str] = []

        return JavaMethod(
            name=ctor_name,
            return_type="void",
            parameters=parameters,
            modifiers=modifiers,
            annotations=annotations,
            javadoc=javadoc,
            throws=throws,
            is_constructor=True,
        )

    def _extract_fields(self, field_ctx, parent_ctx) -> list[JavaField]:
        """Extract JavaField(s) from field declaration context."""
        fields = []

        # Get type
        field_type = (
            field_ctx.typeType().getText() if field_ctx.typeType() else "unknown"
        )

        # Extract modifiers
        modifiers = self._extract_modifiers(parent_ctx)

        # Extract annotations
        annotations = self._extract_annotations(parent_ctx)

        # Extract javadoc
        javadoc = self._extract_javadoc_for_context(
            parent_ctx
        )  # pylint: disable=assignment-from-none

        # Extract variable declarators
        if field_ctx.variableDeclarators():
            for var_decl in field_ctx.variableDeclarators().variableDeclarator():
                field_name = (
                    var_decl.variableDeclaratorId().identifier().getText()
                    if var_decl.variableDeclaratorId().identifier()
                    else "unknown"
                )

                # Extract initial value
                initial_value = None
                if var_decl.variableInitializer():
                    initial_value = var_decl.variableInitializer().getText()

                field = JavaField(
                    name=field_name,
                    type=field_type,
                    modifiers=modifiers,
                    annotations=annotations,
                    javadoc=javadoc,
                    initial_value=initial_value,
                )
                fields.append(field)

        return fields

    def _extract_parameters(self, params_ctx) -> list[JavaParameter]:
        """Extract parameters from formal parameters context."""
        parameters = []

        if not params_ctx or not params_ctx.formalParameterList():
            return parameters

        param_list = params_ctx.formalParameterList()

        # Extract regular parameters
        if param_list.formalParameter():
            for param_ctx in param_list.formalParameter():
                param = self._extract_parameter(param_ctx)
                if param:
                    parameters.append(param)

        # Extract varargs parameter
        if param_list.lastFormalParameter():
            param = self._extract_last_parameter(param_list.lastFormalParameter())
            if param:
                parameters.append(param)

        return parameters

    def _extract_parameter(self, param_ctx) -> Optional[JavaParameter]:
        """Extract single parameter."""
        param_type = (
            param_ctx.typeType().getText() if param_ctx.typeType() else "unknown"
        )
        param_name = (
            param_ctx.variableDeclaratorId().identifier().getText()
            if param_ctx.variableDeclaratorId().identifier()
            else "unknown"
        )

        # Extract parameter annotations
        annotations = []
        if param_ctx.variableModifier():
            for modifier in param_ctx.variableModifier():
                if modifier.annotation():
                    ann = self._extract_annotation(modifier.annotation())
                    if ann:
                        annotations.append(ann)

        return JavaParameter(
            name=param_name,
            type=param_type,
            annotations=annotations,
        )

    def _extract_last_parameter(self, param_ctx) -> Optional[JavaParameter]:
        """Extract last parameter (potentially varargs)."""
        param_type = (
            param_ctx.typeType().getText() if param_ctx.typeType() else "unknown"
        )

        # Add varargs notation if present
        if param_ctx.ELLIPSIS():
            param_type += "..."

        param_name = (
            param_ctx.variableDeclaratorId().identifier().getText()
            if param_ctx.variableDeclaratorId().identifier()
            else "unknown"
        )

        annotations = []
        if param_ctx.variableModifier():
            for modifier in param_ctx.variableModifier():
                if modifier.annotation():
                    ann = self._extract_annotation(modifier.annotation())
                    if ann:
                        annotations.append(ann)

        return JavaParameter(
            name=param_name,
            type=param_type,
            annotations=annotations,
        )

    def _extract_modifiers(self, ctx) -> list[str]:
        """Extract modifiers from context."""
        modifiers = []

        if not ctx or not hasattr(ctx, "modifier"):
            return modifiers

        if ctx.modifier():
            for modifier in ctx.modifier():
                modifier_text = modifier.getText()
                # Only add actual modifiers, not annotations
                if not modifier_text.startswith("@"):
                    modifiers.append(modifier_text)

        return modifiers

    def _extract_annotations(self, ctx) -> list[JavaAnnotation]:
        """Extract annotations from context."""
        annotations = []

        if not ctx or not hasattr(ctx, "modifier"):
            return annotations

        if ctx.modifier():
            for modifier in ctx.modifier():
                if (
                    modifier.classOrInterfaceModifier()
                    and modifier.classOrInterfaceModifier().annotation()
                ):
                    ann = self._extract_annotation(
                        modifier.classOrInterfaceModifier().annotation()
                    )
                    if ann:
                        annotations.append(ann)

        return annotations

    def _extract_annotation(self, ann_ctx) -> Optional[JavaAnnotation]:
        """Extract single annotation."""
        if not ann_ctx or not ann_ctx.qualifiedName():
            return None

        ann_name = "@" + ann_ctx.qualifiedName().getText()

        # TODO: Extract annotation parameters
        parameters = {}

        return JavaAnnotation(name=ann_name, parameters=parameters)

    def _extract_javadoc_for_context(self, _ctx) -> Optional:
        """Extract Javadoc comment for a given context."""
        # ANTLR4 doesn't provide direct access to comments
        # This is a simplified implementation
        # In a full implementation, we would need to access hidden tokens
        return None

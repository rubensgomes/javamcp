# Generated by Claude
"""
Query engine for searching and filtering indexed Java APIs.
"""

from typing import Optional

from javamcp.models.java_entities import JavaClass, JavaMethod

from .exceptions import IndexNotBuiltError, RepositoryNotIndexedError
from .indexer import APIIndexer


class QueryEngine:
    """
    Provides search and filtering capabilities over indexed Java APIs.
    """

    def __init__(self, indexer: APIIndexer):
        """
        Initialize query engine with an indexer.

        Args:
            indexer: APIIndexer instance to query
        """
        self.indexer = indexer

    def search_methods(
        self,
        method_name: str,
        class_name: Optional[str] = None,
        case_sensitive: bool = False,
    ) -> list[tuple[JavaClass, JavaMethod]]:
        """
        Search for methods by name with optional class filter.

        Args:
            method_name: Method name to search for
            class_name: Optional class name filter
            case_sensitive: Whether search is case-sensitive

        Returns:
            List of (JavaClass, JavaMethod) tuples

        Raises:
            IndexNotBuiltError: If index is not built
        """
        if not self.indexer.is_built():
            raise IndexNotBuiltError("Index has not been built")

        results = []

        # Get all methods matching the name
        if case_sensitive:
            matching_methods = self.indexer.get_methods_by_name(method_name)
        else:
            # Case-insensitive search
            matching_methods = []
            for name, methods in self.indexer.method_index.items():
                if name.lower() == method_name.lower():
                    matching_methods.extend(methods)

        # Apply class name filter if specified
        if class_name:
            if case_sensitive:
                results = [
                    (cls, method)
                    for cls, method in matching_methods
                    if cls.name == class_name
                ]
            else:
                results = [
                    (cls, method)
                    for cls, method in matching_methods
                    if cls.name.lower() == class_name.lower()
                ]
        else:
            results = matching_methods

        return results

    def search_methods_partial(
        self, method_name_pattern: str, case_sensitive: bool = False
    ) -> list[tuple[JavaClass, JavaMethod]]:
        """
        Search for methods by partial name matching.

        Args:
            method_name_pattern: Partial method name pattern
            case_sensitive: Whether search is case-sensitive

        Returns:
            List of (JavaClass, JavaMethod) tuples

        Raises:
            IndexNotBuiltError: If index is not built
        """
        if not self.indexer.is_built():
            raise IndexNotBuiltError("Index has not been built")

        results = []

        # Search through all method names
        for name, methods in self.indexer.method_index.items():
            if case_sensitive:
                if method_name_pattern in name:
                    results.extend(methods)
            else:
                if method_name_pattern.lower() in name.lower():
                    results.extend(methods)

        return results

    def search_class(
        self, class_name: str, case_sensitive: bool = False
    ) -> Optional[JavaClass]:
        """
        Search for a class by fully-qualified name.

        Args:
            class_name: Fully-qualified class name
            case_sensitive: Whether search is case-sensitive

        Returns:
            JavaClass or None if not found

        Raises:
            IndexNotBuiltError: If index is not built
        """
        if not self.indexer.is_built():
            raise IndexNotBuiltError("Index has not been built")

        if case_sensitive:
            return self.indexer.get_class_by_fqn(class_name)

        # Case-insensitive search
        for fqn, java_class in self.indexer.class_index.items():
            if fqn.lower() == class_name.lower():
                return java_class
        return None

    def filter_classes_by_repository(self, repository_url: str) -> list[JavaClass]:
        """
        Filter classes by repository URL.

        Args:
            repository_url: Repository URL to filter by

        Returns:
            List of JavaClass objects from repository

        Raises:
            IndexNotBuiltError: If index is not built
            RepositoryNotIndexedError: If repository not in index
        """
        if not self.indexer.is_built():
            raise IndexNotBuiltError("Index has not been built")

        classes = self.indexer.get_classes_by_repository(repository_url)

        if not classes:
            raise RepositoryNotIndexedError(f"Repository not indexed: {repository_url}")

        return classes

    def filter_classes_by_package(
        self, package_name: str, repository_url: Optional[str] = None
    ) -> list[JavaClass]:
        """
        Filter classes by package name with optional repository filter.

        Args:
            package_name: Package name to filter by
            repository_url: Optional repository URL filter

        Returns:
            List of JavaClass objects in package

        Raises:
            IndexNotBuiltError: If index is not built
        """
        if not self.indexer.is_built():
            raise IndexNotBuiltError("Index has not been built")

        classes = self.indexer.get_classes_by_package(package_name)

        # Apply repository filter if specified
        if repository_url:
            repo_classes = set(
                c.fully_qualified_name
                for c in self.indexer.get_classes_by_repository(repository_url)
            )
            classes = [c for c in classes if c.fully_qualified_name in repo_classes]

        return classes

    def get_all_apis_from_repository(self, repository_url: str) -> list[JavaClass]:
        """
        Get all APIs from a specific repository.

        Args:
            repository_url: Repository URL

        Returns:
            List of all JavaClass objects from repository

        Raises:
            IndexNotBuiltError: If index is not built
            RepositoryNotIndexedError: If repository not in index
        """
        return self.filter_classes_by_repository(repository_url)

    def get_all_apis_from_package(
        self, package_name: str, repository_url: str
    ) -> list[JavaClass]:
        """
        Get all APIs from a specific package in a repository.

        Args:
            package_name: Package name
            repository_url: Repository URL

        Returns:
            List of JavaClass objects

        Raises:
            IndexNotBuiltError: If index is not built
        """
        return self.filter_classes_by_package(package_name, repository_url)

    def get_classes_by_name(
        self, class_name: str, case_sensitive: bool = False
    ) -> list[JavaClass]:
        """
        Get classes by simple class name.

        Args:
            class_name: Simple class name
            case_sensitive: Whether search is case-sensitive

        Returns:
            List of matching JavaClass objects

        Raises:
            IndexNotBuiltError: If index is not built
        """
        if not self.indexer.is_built():
            raise IndexNotBuiltError("Index has not been built")

        if case_sensitive:
            return self.indexer.get_classes_by_name(class_name)

        # Case-insensitive search
        results = []
        for name, classes in self.indexer.class_name_index.items():
            if name.lower() == class_name.lower():
                results.extend(classes)
        return results

    def get_statistics(self) -> dict[str, int]:
        """
        Get index statistics.

        Returns:
            Dictionary with statistics (total_classes, total_methods, etc.)
        """
        return {
            "total_classes": self.indexer.get_total_classes(),
            "total_methods": self.indexer.get_total_methods(),
            "total_repositories": len(self.indexer.repository_index),
            "total_packages": len(self.indexer.package_index),
        }
